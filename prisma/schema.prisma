// Precious Metals Marketplace - PostgreSQL schema
// Run: npx prisma generate && npx prisma migrate dev

datasource db {
  provider = "postgresql"
  // The 'url' line is GONE now
}

generator client {
  provider = "prisma-client-js"
  engineType = "library" 
}

enum Role {
  BUYER
  SELLER
  ADMIN
}

enum MetalType {
  GOLD
  SILVER
  PLATINUM
  PALLADIUM
}

enum ListingCondition {
  NEW
  MINT
  EXCELLENT
  GOOD
  FAIR
}

enum OrderStatus {
  PENDING_PAYMENT
  PAID_ESCROW
  SELLER_SHIPPING
  SHIPPED
  DELIVERED
  BUYER_CONFIRMED
  COMPLETED
  DISPUTED
  CANCELLED
  REFUNDED
}

enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  RESOLVED_BUYER
  RESOLVED_SELLER
  REFUNDED
  CLOSED
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  passwordHash  String?   // null if OAuth-only
  name          String?
  image         String?
  role          Role      @default(BUYER)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts    Account[]
  sessions    Session[]
  listings    Listing[]       @relation("SellerListings")
  ordersAsBuyer  Order[]      @relation("BuyerOrders")
  ordersAsSeller Order[]      @relation("SellerOrders")
  reviewsGiven   Review[]     @relation("Reviewer")
  reviewsReceived Review[]    @relation("Reviewee")
  wallet       Wallet?
  disputesAsBuyer  Dispute[]  @relation("BuyerDisputes")
  disputesAsSeller Dispute[]  @relation("SellerDisputes")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Live/cached spot prices (updated by cron or API)
model SpotPrice {
  id        String   @id @default(cuid())
  metal     MetalType
  priceUsd  Decimal  @db.Decimal(18, 4)
  currency  String   @default("USD")
  source    String?
  fetchedAt DateTime @default(now())

  @@index([metal, fetchedAt])
}

model Listing {
  id          String           @id @default(cuid())
  sellerId    String
  title       String
  description String           @db.Text
  metal       MetalType
  weightOz    Decimal          @db.Decimal(12, 6) // troy oz
  priceUsd    Decimal          @db.Decimal(18, 2)
  premiumOverSpot Decimal?     @db.Decimal(8, 4)  // e.g. 0.05 = 5%
  condition   ListingCondition
  images      String[]         // URLs
  status      String           @default("ACTIVE") // ACTIVE, SOLD, REMOVED
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  seller   User     @relation("SellerListings", fields: [sellerId], references: [id], onDelete: Cascade)
  orders   Order[]

  @@index([metal, status])
  @@index([sellerId])
}

model Order {
  id                String      @id @default(cuid())
  buyerId           String
  sellerId          String
  listingId         String
  quantity          Int         @default(1)
  totalAmountCents  Int         // stored in cents for precision
  platformFeeCents  Int         @default(0)
  stripePaymentIntentId String? @unique
  status            OrderStatus @default(PENDING_PAYMENT)
  trackingNumber    String?
  trackingCarrier   String?
  shippedAt         DateTime?
  deliveredAt       DateTime?
  confirmedAt      DateTime?
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  buyer   User     @relation("BuyerOrders", fields: [buyerId], references: [id], onDelete: Cascade)
  seller  User     @relation("SellerOrders", fields: [sellerId], references: [id], onDelete: Cascade)
  listing Listing  @relation(fields: [listingId], references: [id], onDelete: Restrict)
  dispute Dispute?

  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
}

model Wallet {
  id        String   @id @default(cuid())
  userId    String   @unique
  balanceCents Int   @default(0) // available balance
  pendingCents  Int  @default(0) // in escrow
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Review {
  id        String   @id @default(cuid())
  orderId   String   // denormalized for display
  reviewerId String
  revieweeId String  // seller
  rating    Int      // 1-5
  comment   String?  @db.Text
  createdAt DateTime @default(now())

  reviewer User @relation("Reviewer", fields: [reviewerId], references: [id], onDelete: Cascade)
  reviewee User @relation("Reviewee", fields: [revieweeId], references: [id], onDelete: Cascade)

  @@unique([orderId, reviewerId])
  @@index([revieweeId])
}

model Dispute {
  id          String        @id @default(cuid())
  orderId     String        @unique
  buyerId     String
  sellerId    String
  status      DisputeStatus @default(OPEN)
  reason      String        @db.Text
  adminNotes  String?       @db.Text
  resolvedAt  DateTime?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  order  Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  buyer  User   @relation("BuyerDisputes", fields: [buyerId], references: [id], onDelete: Cascade)
  seller User   @relation("SellerDisputes", fields: [sellerId], references: [id], onDelete: Cascade)
}
